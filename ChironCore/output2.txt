Chiron v5.3

    ░█████╗░██╗░░██╗██╗██████╗░░█████╗░███╗░░██╗
    ██╔══██╗██║░░██║██║██╔══██╗██╔══██╗████╗░██║
    ██║░░╚═╝███████║██║██████╔╝██║░░██║██╔██╗██║
    ██║░░██╗██╔══██║██║██╔══██╗██║░░██║██║╚████║
    ╚█████╔╝██║░░██║██║██║░░██║╚█████╔╝██║░╚███║
    ░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚══╝
    
assume(:x > 0)
if (:x > 0)[
    :sign = 1
] else [
    :sign = 0
]
if (:x < 0)[
    :sign = -1
]
assert(:sign == 1)
assume(:x > 0)
if (:x > 0)[
    :sign = 1
] else [
    :sign = 0
]
if (:x < 0)[
    :sign = -1
]
assert(:sign == 1)
{<cfg.ChironCFG.BasicBlock object at 0x725863f06d80>: {':x_0': 0}, <cfg.ChironCFG.BasicBlock object at 0x725862b97d70>: {':sign_1': 1}, <cfg.ChironCFG.BasicBlock object at 0x725862b97bc0>: {':sign_3': 1}, <cfg.ChironCFG.BasicBlock object at 0x725862b97dd0>: {':x_4': 0}, <cfg.ChironCFG.BasicBlock object at 0x725862bca600>: {':sign_5': 1}, <cfg.ChironCFG.BasicBlock object at 0x725862bca5a0>: {}, <cfg.ChironCFG.BasicBlock object at 0x725862bc8350>: {':sign_8': 0}}
['((:x_0_0 > 0))', '(:x_0_0 > 0)', ':x_1_0 = :x_0_0', ':sign_1_0 = :sign_0_0', ':x_3_0 = :x_0_0', ':sign_3_0 = :sign_0_0']
['((:sign_8_0 == 1))']
[['assign', [':x_1_0 = :x_0_0', ':sign_1_0 = :sign_0_0', ':x_3_0 = :x_0_0', ':sign_3_0 = :sign_0_0']], ['if-else', '(:x_0_0 > 0)', [':sign_1_1=1', ':x_4_0 = :x_1_0', ':sign_4_0 = :sign_1_1'], [':sign_3_1=0', ':x_4_0 = :x_3_0', ':sign_4_0 = :sign_3_1']], ['assign', [':sign_1_1=1', ':x_4_0 = :x_1_0', ':sign_4_0 = :sign_1_1']], ['assign', [':sign_3_1=0', ':x_4_0 = :x_3_0', ':sign_4_0 = :sign_3_1']], ['assign', [':sign_5_0 = :sign_4_0', ':sign_7_0 = :sign_4_0']], ['if-else', '(:x_4_0 < 0)', [':sign_5_1=-1', ':sign_8_0 = :sign_5_1'], [':sign_8_0 = :sign_7_0']], ['assign', [':sign_5_1=-1', ':sign_8_0 = :sign_5_1']], ['assign', [':sign_8_0 = :sign_7_0']], ['assign', []]]
Pre-condition:  (and (> x_0_0 0) (> x_0_0 0) (= x_1_0 x_0_0) (= sign_1_0 sign_0_0) (= x_3_0 x_0_0) (= sign_3_0 sign_0_0) true)

Post-condition:  (= sign_8_0 1)
Code-body:  (and (= x_1_0 x_0_0)(= sign_1_0 sign_0_0)(= x_3_0 x_0_0)(= sign_3_0 sign_0_0)(or (and (> x_0_0 0) (and (= sign_1_1 1) (= x_4_0 x_1_0) (= sign_4_0 sign_1_1) true)
) (and (not (> x_0_0 0)) (and (= sign_3_1 0) (= x_4_0 x_3_0) (= sign_4_0 sign_3_1) true)
))(= sign_1_1 1)(= x_4_0 x_1_0)(= sign_4_0 sign_1_1)(= sign_3_1 0)(= x_4_0 x_3_0)(= sign_4_0 sign_3_1)(= sign_5_0 sign_4_0)(= sign_7_0 sign_4_0)(or (and (< x_4_0 0) (and (= sign_5_1 (- 1)) (= sign_8_0 sign_5_1) true)
) (and (not (< x_4_0 0)) (= sign_8_0 sign_7_0)))(= sign_5_1 (- 1))(= sign_8_0 sign_5_1)(= sign_8_0 sign_7_0)true)

(declare-fun sign_1_0 () Int)
(declare-fun sign_5_1 () Int)
(declare-fun sign_3_1 () Int)
(declare-fun sign_1_1 () Int)
(declare-fun x_4_0 () Int)
(declare-fun sign_3_0 () Int)
(declare-fun sign_8_0 () Int)
(declare-fun sign_7_0 () Int)
(declare-fun sign_0_0 () Int)
(declare-fun x_0_0 () Int)
(declare-fun sign_5_0 () Int)
(declare-fun x_3_0 () Int)
(declare-fun x_1_0 () Int)
(declare-fun sign_4_0 () Int)
(assert (not (=> (and (and (> x_0_0 0) (> x_0_0 0) (= x_1_0 x_0_0) (= sign_1_0 sign_0_0) (= x_3_0 x_0_0) (= sign_3_0 sign_0_0) true)
 (and (= x_1_0 x_0_0)(= sign_1_0 sign_0_0)(= x_3_0 x_0_0)(= sign_3_0 sign_0_0)(or (and (> x_0_0 0) (and (= sign_1_1 1) (= x_4_0 x_1_0) (= sign_4_0 sign_1_1) true)
) (and (not (> x_0_0 0)) (and (= sign_3_1 0) (= x_4_0 x_3_0) (= sign_4_0 sign_3_1) true)
))(= sign_1_1 1)(= x_4_0 x_1_0)(= sign_4_0 sign_1_1)(= sign_3_1 0)(= x_4_0 x_3_0)(= sign_4_0 sign_3_1)(= sign_5_0 sign_4_0)(= sign_7_0 sign_4_0)(or (and (< x_4_0 0) (and (= sign_5_1 (- 1)) (= sign_8_0 sign_5_1) true)
) (and (not (< x_4_0 0)) (= sign_8_0 sign_7_0)))(= sign_5_1 (- 1))(= sign_8_0 sign_5_1)(= sign_8_0 sign_7_0)true)
) (= sign_8_0 1))))
(check-sat)
(get-model)


======Z3 Output:======
 unsat
(error "line 22 column 10: model is not available")

